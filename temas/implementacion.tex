\chapter{Implemetación}

\section{Transacciones}

Una transacción es un conjunto de instrucciones que forman una unidad lógica de procesamiento.

La base de datos está compuesta por items, que pueden ser registros, atributos, bloques de memoria.
Cada item tiene un identificador único (que no necesita ser conocido por el programador).
Una transacción es una secuencia de lecturas y escrituras de items.

\begin{description}
	\item[read-set:] conjunto de items leídos por una transacción
	\item[write-set:] conjunto de items escritos por una transacción
\end{description}

Problemas comunes:

\begin{description}
	\item[Lost Update:] T1 lee X, T2 lee X, T1 escribe X usando el valor que leyó, T2 escribe X usando el valor que leyó
	\item[Dirty Read:] leo algo que luego es abortado y rollbackeado
	\item[Incorrect Summary:] T1 modifica algo que T2 estaba sumarizando y T2 obtiene mal el resultado
	\item[Unrepeatable read:] Ocurre cuando dentro de una transacción, dos reads (uno atrás del otro o sin modificar los datos), leen diferentes valores del mismo dato
\end{description}

Una Transacción T alcanza su punto de commit cuando: operaciones ejecutadas correctamente y grabadas en el log.

Propiedades ACID:

\begin{description}
	\item[Atomicidad:] una transacción es una unidad atómica. Responsabilidad del subsistema de recovery
	\item[Consistencia:] una transacción mueve la BD de un estado consistente a otro. Responsabilidad dividida entre el programador y el módulo de restricciones de integridad del DBMS
	\item[Aislamiento:] las transacciones no deben interferir entre ellas. Deben correr como si fueran la única transacción en el sistema. Impuesto por el subsistema de concurrencia
	\item[Durabilidad:] los cambios commiteados deben persistir en la BD. Responsabilidad del subsistema de recovery
\end{description}

Conflicto equivalencia: dos historias $H_1$ y $H_2$ son conflicto equivalentes si tienen las mismas transacciones y el
orden de las operaciones en conflicto de las transacciones no abortadas es el mismo.

Historia recuperable: Si $T_i$ lee de $T_j$ y $T_i$ commitea, entonces $c_i > c_j$

Avoid cascaiding Aborts: se leen solo datos ya commiteados. De esa forma se pueden evitar los dirty reads sin abortar como en RC.

Historia estricta: no lee ni escribe un item que fue escrito por una transacción que no commiteó.

\section{NoSQL}

\begin{description}
	\item[Basadas en documentos:] cada entrada es un documento, sin esquema pero con algún formato (semi estructurado). Ejemplo: JSONs en MongoDB
\end{description}

Sharding: metodología que distribuye filas de una misma tabla en distintos nodos. Es fragmentación horizontal.

BASE:

Basic Availability: siempre se puede responder consultas (no se cae)

Soft state: cambios sin necesidad de entradas nuevas

Eventual consistency

CAP: de consistencia, availability, partition tolerance solo podes tener dos

\section{Optimización de consultas}

Indice denso: tiene una entrada por cada registro de la BD. No es denso si tiene puntero a bloque en el que tenes que buscar.

Optimizaciones algebraicas:

Hacer proyecciones y selecciones lo antes posible (mas en las hojas).

Aplicar primero los joins mas selectivos

Cambiar producto cartesiano + seleccion por join

Hacer primero las selecciones más selectivas

Selectividad: proporción de tuplas que cumplen la condición.

Hacer seleccion de relaciones y luego producto cartesiano en vez de producto cartesiano y luego seleccion: $\sigma(R \times S) = \sigma(R) \times \sigma(S)$

Sorted merge join: se ordenan ambas tablas (o ya están ordenadas por un indice) y se mergea como en merge sort.

\section{Concurrencia}

Problemas:

Phantom read: hago dos selects iguales en la misma transaccion y dan conjuntos de tuplas distintos

Historia serializable: (conflicto) equivalente a una serial. Para chequear se hace digrafo de precedencia (operaciones en conflicto entre transacciones) y no tiene que tener ciclos.

Timestamping con multiversion: busca evitar \textbf{read too late}, al escribir no se pisa el registro sino que se crea una nueva versión y se le asigna un timestamp. Asi, si una transacción más vieja quiere leer un registro que fue escrito por una transacción mas nueva, puede leer la versión correspondiente. No evita aborts en cascada ni write too late.

\section{Recuperación}

Politica Undo+Redo: Hace undo de las transacciones incompletas y luego redo de las transacciones commiteadas en el log. Las filas del log tienen las escrituras con valor viejo y valor nuevo para poder hacer redo.

Checkpoint quiescente: no permite nuevas transacciones hasta que terminen las que estaban pendientes de commitear.

Checkpoint no quiescente: permite nuevas transacciones, solo espera a las que estaban pendientes de antes para terminar el checkpoint.

\section{Bases distribuidas}

Sistemas de replicacion:

master/slave

peer to peer

Homogéneo: todos los nodos corren el mismo software (o compatible), y comparten esquemas.

Heterogéneo: cada nodo usa software y esquema distinto y colaboran de forma limitada.
